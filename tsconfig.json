{
  "compilerOptions": {
    "module": "commonjs", // 规定了项目的模块化方式，选项有 AMD，UMD，commonjs 等。
    "target": "esnext",
    "allowJs": true, // 顾名思义，允许在 TypeScript 项目中使用 JavaScript，这在从 JavaScript 迁移到 TypeScript 中是非常重要的。
    "sourceMap": true,
    "esModuleInterop": true, // 解决了 函数组件 TypeError: Cannot read property 'createElement' of undefined 问题
    // 目前很多常用的包是基于 cjs / UMD 开发的，而写前端代码一般是写 esm，所以常见的场景是 esm 导入 cjs 的库。
    // 但是由于 esm 和 cjs 存在概念上的差异，最大的差异点在于 esm 有 default 的概念而 cjs 没有，所以在 default 上会出问题。
    // TS babel webpack 都有自己的一套处理机制来处理这个兼容问题，核心思想基本都是通过 default 属性的增添和读取
    "moduleResolution": "node", // 告诉TypeScript编译器，采用何种方式解析（也就是查找）TypeScript文件中依赖的模块的位置，可选项为：Classic和Node
    "lib": ["esnext", "dom"], // lib用于指定要包含在编译中的库文件
    "outDir": "dist", // outDir 和 outFile 这两个配置则是告诉 TypeScript 将文件生成到哪里。
    "experimentalDecorators": true, // 用于指定是否启用实验性的装饰器特性
    "emitDecoratorMetadata": true, // 用于指定是否为装上去提供元数据支持
    "allowSyntheticDefaultImports": true, // 用来指定允许从没有默认导出的模块中默认导入
    "noImplicitAny": false,// false 不检查隐式any类型
    "strict": false, // 改为false - 严格模式
    "suppressImplicitAnyIndexErrors": true
  },
  "include": [
    "service/**/*"
  ],
  "compileOnSave": true, // 在最顶层设置compileOnSave标记，可以让IDE在保存文件的时候根据tsconfig.json重新生成文件。
  "exclude": [
    "node_modules",
    "dist",
    "dashboard",
    "static",
    "views",
    "db"
  ]
}
